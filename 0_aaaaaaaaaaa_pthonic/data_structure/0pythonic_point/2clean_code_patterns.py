"""
整洁的Python代码模式 Clean Code Patterns

1、自由使用断言
2、逗号应该放在哪里
3、上下文管理器的---with---语句
4、魔术方法、下划线和其他功能
5、关于格式化字符串的秘密
"""
print('-------------------------------------自由使用断言---------------------------------------------')
"""在Python中，断言（assertions）是一种用于在程序执行过程中进行条件检查的工具。
它们主要用于在开发阶段帮助程序员快速发现代码中的错误或不符合预期的行为。
当断言条件为假（即断言失败）时，程序会---立即停止运行----，并抛出AssertionError异常，显示相关的错误信息。
断言不应该用于处理常规运行时的错误，而是用于在开发和测试期间确保程序的内部状态符合预期。
"""


# pythonic
def divide(a: float, b: float) -> float:
    assert b != 0, "Divider cannot be zero."
    return a / b


# result = divide(10, 0)

# 在类的内部，断言可用于检查对象的状态是否处于有效范围内，避免后续操作导致错误
class Stack:
    def __init__(self):
        self._items = []

    def push(self, item):
        self._items.append(item)

    def pop(self):
        assert len(self._items) > 0, "Cannot pop from an empty stack."
        return self._items.pop()


# stack = Stack()
# stack.pop()


# 在复杂的计算或算法中，断言可用于验证中间步骤的结果，有助于调试过程。
def find_max_subarray_sum(arr):
    assert len(arr) > 0, "Array must have at least one element."

    max_sum = arr[0]
    current_sum = arr[0]

    for i in range(1, len(arr)):
        current_sum = max(arr[i], current_sum + arr[i])
        max_sum = max(max_sum, current_sum)

    return max_sum


# find_max_subarray_sum([])
# 该示例中，断言确保输入数组至少包含一个元素，防止对空数组进行无效操作
"""
4. 开发与生产环境的区别
断言在开发和测试环境中非常有用，但在生产环境中，为了提高程序的健壮性，通常会选择关闭断言（通过python -O命令行选项或PYTHONOPTIMIZE环境变量）。
因此，不应依赖断言来处理可能在生产环境中出现的错误情况，而应使用常规的错误处理机制（如try-except）。

5. 使用断言的最佳实践
断言语句应简洁明了，易于理解其检查的条件。
尽量避免在循环体内部使用断言，因为断言失败会导致程序立即停止，可能掩盖了其他潜在问题。
不要在性能关键的代码路径中使用断言，因为它们会引入额外的条件检查开销。
对于用户输入的验证，通常使用异常处理而非断言，因为用户输入错误是预期中的运行时情况。

总之，自由使用断言意味着在适当的地方（如验证条件、检查状态、确认中间结果等）利用它们来辅助开发和调试，确保代码逻辑的正确性。
但要注意断言并非处理常规错误的手段，且在生产环境中可能被关闭，因此应结合正常的错误处理机制来保证程序的健壮性。
"""

print('-------------------------------------逗号应该放在哪里---------------------------------------------')

print('-------------------------------------上下文管理器的---with---语句---------------------------------------------')

print('-------------------------------------魔术方法、下划线和其他功能---------------------------------------------')
"""
下划线开头的方法不会被倒入

您提到的“下划线开头的方法不会被倒入”这一说法，指的是在Python编程中的一种常见约定和实践。
具体来说，当一个方法（函数）或属性（变量）的名称以单个下划线 _ 开头时，通常具有以下含义和效果：

私有性暗示：虽然在Python中没有严格意义上的私有成员（如其他一些语言中的private关键字），
    但以单下划线开头的标识符被视为“私有的”，这是一种约定俗成的编程习惯。
    这意味着这些方法或属性是为类的内部使用设计的，外部代码（如类的使用者或客户端代码）不应直接访问它们。
    这样的命名方式是对调用者的一种提示，表明这些成员是内部实现细节，不应依赖于它们，因为它们可能在未来版本中发生变化而不予通知。
    
避免名称冲突：使用下划线开头可以帮助避免与客户端代码中的其他标识符发生冲突，特别是在模块级别或类级别导入时。

当使用from module import *这样的语句进行“星号导入”时，Python会忽略以单下划线开头的名称。
    这样可以确保仅导入公开的、设计为对外可见的API，而不引入那些旨在保持内部私有的方法或属性。
    
下划线结尾：是为了和关键字做区分


在Python中，类的变量（属性）如果以双下划线__开头（通常称为“双下划线”或“双下划线前缀”），则涉及Python的名称修饰（Name Mangling）机制。
这种机制主要出于以下目的：
**1. 增强封装性：双下划线前缀的变量旨在提高类的内部属性的封装性，减少外部代码对这些属性的直接访问。
    虽然Python本身并不支持严格的私有属性，但双下划线前缀提供了一种方式来减少无意或恶意的外部访问。
    名称修饰使得这些属性在类的外部变得不易见，从而鼓励程序员遵守封装原则，避免直接操作类的内部细节。
**2. 避免名称冲突：特别是在多重继承或嵌套类的场景中，双下划线前缀有助于避免属性名与子类或父类中的同名属性发生冲突。
    名称修饰机制会修改这类属性的实际名称，使得它们在类的内部和外部表现得像是具有不同名称的变量。
    
名称修饰的具体实现：
当一个类的属性以双下划线__var开头时，Python解释器会对其进行名称修饰，将其实际名称变为_ClassName__var。
    这里的ClassName是该属性所属类的名称。这样，即使在类的外部或子类中存在同名属性，经过名称修饰后的内部属性也不会与之混淆。
例如：
class MyClass:
    def __init__(self):
        self.__private_var = "This is private"

obj = MyClass()
print(obj.__private_var)  # 抛出 AttributeError，无法直接访问

# 但实际上，通过名称修饰后的名称仍然可以访问（但这违反了封装原则）
print(obj._MyClass__private_var)  # "This is private"

注意事项：
并非真正的私有：虽然名称修饰增强了封装性，但它并没有创建真正的私有属性。外部代码仍然可以通过访问修饰后的名称来获取或修改这些变量。
    遵循Python的编码规范，外部代码应当避免直接访问双下划线前缀的属性，尊重类的封装性。
不适用于模块级变量：名称修饰仅适用于类的属性，而不适用于模块级别的变量。在模块级别，双下划线前缀的变量不会经历名称修饰。
不适用于单下划线前缀：单下划线前缀（如_var）的变量不会触发名称修饰，它们仅作为一种编程约定，表示变量或方法是内部实现细节，不建议外部直接访问。


以双下划线__开头并以双下划线__结尾的变量（或方法）具有特殊含义，它们是Python语言预留给特定用途的保留字。
    这种形式的标识符通常被称为“魔法方法”（Magic Methods），因为它们在Python对象模型中扮演着重要角色，提供了类的行为特性和面向对象编程的高级特性。

以下是一些常见的魔法方法示例及其作用

class Example:
    def __init__(self, value):  # 构造函数
        self.value = value

    def __str__(self):  # 对象的字符串表示
        return f"Example object with value {self.value}"

    def __repr__(self):  # 对象的可复现表示（通常用于调试）
        return f"Example({self.value})"

    def __eq__(self, other):  # 等价性检查
        return isinstance(other, Example) and self.value == other.value

    def __add__(self, other):  # 支持加法运算
        if isinstance(other, Example):
            return Example(self.value + other.value)
        else:
            raise TypeError("Unsupported operand type(s)")

    # 更多魔法方法...
    
魔法方法的作用和用途：
对象生命周期管理：如__init__（构造函数）、__del__（析构函数）等，用于控制对象的创建、初始化和销毁过程。

对象表示和转换：如__str__（返回对象的用户友好字符串表示）、__repr__（返回对象的可复现字符串表示，通常用于调试）、__bytes__、__format__等，
    用于将对象转化为不同格式的字符串或其他类型。

比较和排序：如__eq__（等于）、__ne__（不等于）、__lt__（小于）、__gt__（大于）、__le__（小于等于）、__ge__（大于等于）、__hash__（哈希值计算）、
    __cmp__（旧版比较方法，已被弃用）、__lt__、__gt__、__le__、__ge__等，用于定义对象之间的比较关系和排序规则。

算术和位运算：如__add__（加法）、__sub__（减法）、__mul__（乘法）、__truediv__（真除法）、__floordiv__（整数除法）、__mod__（取模）、
    __pow__（幂运算）、__and__、__or__、__xor__、__lshift__、__rshift__等，使自定义类支持相应的数学运算和位运算。
    
容器操作：如__len__（长度）、__getitem__（索引）、__setitem__（设置索引）、__delitem__（删除索引）、__iter__（迭代器）、
    __contains__（成员资格检查）、__reversed__（反向迭代）等，使自定义类具备类似列表、字典等容器的行为。
    
上下文管理协议：如__enter__、__exit__，使自定义类支持with语句，实现资源的自动获取和释放。

其他：还有许多其他魔法方法，如__getattr__（获取不存在的属性时调用）、__setattr__（设置属性时调用）、__getattribute__（始终在访问属性时调用）、
    __call__（使对象可调用）等，用于实现更复杂的行为和定制化需求。
"""
print('-------------------------------------关于格式化字符串的秘密---------------------------------------------')
