print('------')
"""在进行对象赋值操作时，Python 都不会进行深度复制。相反，您只需创建一个引用并将名称绑定到对象。
    对于不可变或只读对象，副本的类型无关紧要。但是，对于可以修改的对象，数据的浅拷贝在多个引用中共享同一个对象
        ————因此，无论是否有意，更改底层对象将影响所有引用。对于可变对象，应始终首选深拷贝。
        
通过例子结合内存布局的图解分析了浅层克隆（shallow copy）的原理以及使用的要点。
    再有通过源代码的分析，也让大家知道了其来龙去脉，达到了知其所以然的目的。
"""
"""
浅拷贝（Shallow Copy）：
    使用 copy() 函数（来自 copy 模块）或者通过列表的 copy() 方法或字典的 copy() 方法创建。
    创建一个新的对象，但只复制原对象的引用，而不是复制对象的内容。
    对于非复合对象（如整数、字符串、元组等不可变类型），浅拷贝和深拷贝没有区别，因为它们已经是不可变的。
    当原对象包含可变对象（如列表、字典）时，浅拷贝后的对象和原对象会共享这些可变对象的引用。这意味着修改其中一个对象的可变元素会影响到另一个。
"""
import copy

original_list = [1, 2, [3, 4]]
shallow_copy = original_list.copy()

# 修改原列表的一个子列表
original_list[2].append(5)

print(original_list)  # 输出: [1, 2, [3, 4, 5]]
print(shallow_copy)  # 输出: [1, 2, [3, 4, 5]]

"""
深拷贝（Deep Copy）：
   使用 deepcopy() 函数（来自 copy 模块）创建。
   不仅创建新对象，而且递归地复制原对象的所有内容，包括可变对象。
   结果是完全独立的对象，修改深拷贝的对象不会影响原对象或浅拷贝的对象。
"""
import copy

original_list = [1, 2, [3, 4]]
deep_copy = copy.deepcopy(original_list)

# 修改原列表的一个子列表
original_list[2].append(5)

print(original_list)  # 输出: [1, 2, [3, 4, 5]]
print(deep_copy)  # 输出: [1, 2, [3, 4]]  # 不受原列表修改的影响

"""选择使用哪种拷贝取决于你是否希望新对象与原对象完全独立，或者允许它们之间共享某些部分。在处理包含可变对象的复杂数据结构时，深拷贝可以避免意外的副作用。
"""

print('-----------------------------------------pythonic 讲解 shallow copy ------------------------------------')
list1 = [[1, 2, 3], [6, 7, 8, 9]]
list2 = list(list1)  # list2=list1.copy() 相同用法

print(id(list1), id(list2))  # 4722633024 4386696064
print(id(list1[1]), id(list2[1]))  # 4410636032 4410636032
list2[1][2] = 99
print(list1, list2)  # [[1, 2, 3], [6, 7, 99, 9]] [[1, 2, 3], [6, 7, 99, 9]]
# 给list2 增加一个元素
list2.append([11, 22, 33])
print(list1, list2)  # [[1, 2, 3], [6, 7, 99, 9]] [[1, 2, 3], [6, 7, 99, 9], [11, 22, 33]]
""" 说明shallow copy 只是复制了最上层的引用,修改第二层的的内容会引起元数据的更改"""
